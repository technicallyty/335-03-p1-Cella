//  Authors:  Tyler Goodman - tygoodman@csu.fullerton.edu
//            Waleed Ali    - wali13@csu.fullerton.edu
// ------------------------------------------------------------
// cs-sketch.js description -
//    this file handles drawing and 'movement' of ant (bot). 
//    a triangle is drawn on each move, with the previous erased.
//    movement is based on colors - red/blue = left, otherwise right.


// Make global g_canvas JS 'object': a key-value 'dictionary'.
var g_canvas = { cell_size: 10, wid: 41, hgt: 41 }; // JS Global var, w canvas size info.
var g_frame_cnt = 0; // Setup a P5 display-frame counter, to do anim
const g_frame_mod = 24; // Update ever 'mod' frames.
var g_stop = 0; // Go by default.

//  global variables to assist with bot movement/erasing
var previousPos = null
var previousColor = null
var triangleDir = 6
var moves = 0;

//  global bot objects
var g_bot = { dir: 0, x: 21, y: 21, color: 100 }; // Dir is 0..7 clock, w 0 up.
var g_box = { t: 1, hgt: 47, l: 1, wid: 63 }; // Box in which bot can move.

//  enum colors for the squares
var colors = {
  red: "#ff0000",
  blue: "#0000ff",
  black: "#000000",
  yellow: "#ffff00",
  green: "#006400",
  white: "#f0f8ff"
}
var testColor = colors.red;

//  enum directionals
var dir = {
  up: 0,
  right: 2,
  down: 4,
  left: 6
}


function setup() {
  // P5 Setup Fcn
  let sz = g_canvas.cell_size;
  let width = sz * g_canvas.wid; // Our 'canvas' uses cells of given size, not 1x1 pixels.
  let height = sz * g_canvas.hgt;
  createCanvas(width, height); // Make a P5 canvas.
  draw_grid(10, 50);


  //  initialize triangle setup
  stroke(colors.white)
  fill(colors.white)
  triangle(210 + 5, 210 + 2, 210 + 3, 210 + 8, 210 + 7, 210 + 8);
  let x = 1 + g_bot.x * sz;
  let y = 1 + g_bot.y * sz;
  previousColor = colors.red
  previousPos = [x, y]
  move_bot();
}



function move_bot() {
  moves++;
  
  let dx = 0;
  let dy = 0;
  let sz = g_canvas.cell_size;
  let xD = 1 + g_bot.x * sz; 
  let yD = 1 + g_bot.y * sz;

  let rgba = get(xD + 1, yD + 1);
  let hexValueFromCell = rgbTohex(rgba[0], rgba[1], rgba[2]);
  let goRight = botShouldGoRight(hexValueFromCell);
  
  if(testColor == colors.green){
    goRight = !goRight;
  };

  if (goRight === false){
    switch(g_bot.dir){
      case dir.up:    {dx = -1; g_bot.dir = dir.left; break;}
      case dir.right: {dy =  1; g_bot.dir = dir.up; break;}
      case dir.down:  {dx =  1; g_bot.dir = dir.right; break;}
      case dir.left:  {dy = -1; g_bot.dir = dir.down; break;}
    }
  } else {
    switch(g_bot.dir){
      case dir.up:    {dx =  1; g_bot.dir = dir.right; break;}
      case dir.right: {dy = -1; g_bot.dir = dir.down; break;}
      case dir.down:  {dx = -1; g_bot.dir = dir.left; break;}
      case dir.left:  {dy =  1; g_bot.dir = dir.up; break;}
    }
  }

  g_bot.x = (dx + g_bot.x); // Update bot x.
  g_bot.y = (dy + g_bot.y) ; // Update bot y.

  
}



function draw_bot() {
  //  'erase' triangle by filling previously visited box with it's own color.
  stroke(previousColor);
  fill(previousColor);
  rect(previousPos[0], previousPos[1], 8, 8);


  // Convert bot pos to grid pos & draw bot.
  let sz = g_canvas.cell_size;
  let x = 1 + g_bot.x * sz; // Set x one pixel inside the sz-by-sz cell.
  let y = 1 + g_bot.y * sz;
  let cellSize = sz - 2; // Stay inside cell walls.

  //increment color on current cell
  let rgba = get(x + 1, y + 1); //  get color of cell out of the way of triangle / border
  let hexValueFromCell = rgbTohex(rgba[0], rgba[1], rgba[2]);
  testColor = hexValueFromCell
  let nextColor = getNextColor(hexValueFromCell);
  stroke(nextColor)
  fill(nextColor)
  rect(x, y, cellSize, cellSize);


  //draw triangle on top of cell
  fill(colors.white);
  stroke(colors.white);
  drawTriangle(x, y, hexValueFromCell)

  //set previous color/pos for erasure on next move
  previousColor = nextColor;
  previousPos = [x, y];
}

function draw_update() {
  draw_bot();
  move_bot();
  moves == 1000 && noLoop();
}

function draw() {
  // P5 Frame Re-draw Fcn, Called for Every Frame.
  ++g_frame_cnt;
  if (0 == g_frame_cnt % g_frame_mod) {
    if (!g_stop) draw_update();
  }
}

//  Don't need this
function keyPressed() {
  g_stop = !g_stop;
}


function botShouldGoRight(hex) {
  if (hex == colors.red || hex == colors.blue) {
    return true;
  } else {
    return false;
  }
}

function getNextColor(hex) {
  switch (hex) {
    case (colors.black): {
      return colors.red;
    }
    case (colors.red): {
      return colors.yellow;
    }
    case (colors.yellow): {
      return colors.blue;
    }
    case (colors.blue): {
      return colors.green;
    }
    case (colors.green): {
      return colors.black;
    }
    default:{
      return colors.black;
    }
  }
}

//  convert the value from P5's 'get' function to a hex string
function rgbTohex(r, g, b) {
  return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

function drawTriangle(x, y, currentColor) { 
  if (currentColor == colors.red || currentColor == colors.blue) {
    switch (g_bot.dir) {
      case (dir.left):  { return triangle(x + 5, y + 2, x + 3, y + 8, x + 7, y + 8); }
      case (dir.up):    { return triangle(x + 2, y + 5, x + 8, y + 3, x + 8, y + 7); }
      case (dir.right): { return triangle(x + 5, y + 7, x + 3, y + 2, x + 7, y + 2); }
      case (dir.down):  { return triangle(x + 7, y + 5, x + 2, y + 3, x + 2, y + 7); }
    }
  } else {
    switch (g_bot.dir) {
      case (dir.left):  { return triangle(x + 5, y + 7, x + 3, y + 2, x + 7, y + 2); }
      case (dir.up):    { return triangle(x + 7, y + 5, x + 2, y + 3, x + 2, y + 7); }
      case (dir.right): { return triangle(x + 5, y + 2, x + 3, y + 8, x + 7, y + 8); }
      case (dir.down):  { return triangle(x + 2, y + 5, x + 8, y + 3, x + 8, y + 7); }
    }
  }
}

